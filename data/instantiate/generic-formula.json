{
    "format": "formula:generic",
    "language": "abella-language",
    "content": ": (forall P1 P2 Q1 Q2, tech P1 P2 Q1 Q2 -> tech Q1 Q2 P1 P2) -> (forall P Q, bisim_up_to P Q -> bisim_up_to Q P)",
    "context": [
        "acontext"
    ],
    "contexts": {
        "acontext": {
            "language": "abella-language",
            "content": [
                "Kind name type",
                "Kind action type",
                "Kind proc type",
                "Type tau action",
                "Type up name -> action",
                "Type dn name -> action",
                "Type plus proc -> proc -> proc",
                "Type par proc -> proc -> proc",
                "Type act action -> proc -> proc",
                "Type repl proc -> proc",
                "Define one : proc -> action -> proc -> prop by one (act A P) A P := true; one (plus P1 P2) A Q := one P1 A Q; one (plus P1 P2) A Q := one P2 A Q; one (par P Q) A (par P1 Q) := one P A P1; one (par P Q) A (par P Q1) := one Q A Q1; one (repl P) A (par (repl P) Q) := one P A Q; one (par P Q) tau (par P1 Q1) := exists (X : name), one P (up X) P1 /\\ one Q (dn X) Q1; one (par P Q) tau (par P1 Q1) := exists (X : name), one P (dn X) P1 /\\ one Q (up X) Q1; one (repl P) tau (par (repl P) (par Q R)) := exists (X : name), one P (up X) Q /\\ one P (dn X) R",
                "CoDefine bisim_up_to : proc -> proc -> prop by bisim_up_to P Q := (forall (A : action) (P1 : proc), one P A P1 -> (exists (Q1 : proc), one Q A Q1 /\\ (exists (P2 : proc) (Q2 : proc), tech P1 P2 Q1 Q2 /\\ bisim_up_to P2 Q2))) /\\ (forall (A : action) (Q1 : proc), one Q A Q1 -> (exists (P1 : proc), one P A P1 /\\ (exists (P2 : proc) (Q2 : proc), tech P1 P2 Q1 Q2 /\\ bisim_up_to P2 Q2)))"
            ]
        }
    },
    "parameter": {
        "placeholder": "tech",
        "type-signature": "proc -> proc -> proc -> proc -> prop"
    }
}